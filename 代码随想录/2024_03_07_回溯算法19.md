## Leetcode 332 Reconstruct Itinerary
本题考查的是主要有几个点
<ol>
<li>如何去保证没有无限循环</li>
<li>如何去保证按照字母排序的顺序问题</li>
<li>如何去通过时间复杂度的限制</li>
</ol>

两种方法，回溯法和深度搜索法都可以解决本题，但是本质上回溯法需要自己去维持全局变量来保证每次进入回溯的状态都是一致的

### 深度搜索法
```python
def findItinerary(self, tickets):
    res = []
    # here we have to use the defaultdict otherwise, there will be key error for the while loop inisde the dfs function
    hashmap = defaultdict(list)
    # formulate the hashmap
    for ticket in tickets:
        if ticket[0] not in hashmap:
            hashmap[ticket[0]] = [ticket[1]]
        else:
            hashmap[ticket[0]].append(ticket[1])
    
    # sort the map to achieve ordered search
    for key, value in hashmap.items():
        hashmap[key] = sorted(value, reverse=True)
    
    def dfs(cur):
        while hashmap[cur]:
            dfs(hashmap[cur].pop())
        res.append(cur)
    
    dfs("JFK")
    return res[::-1]

```

### 回溯法
```python
def findItinerary(self, tickets):
    used = [0] * len(tickets)
    tickets.sort()
    res = []
    cur = "JFK"
    path = [cur]
    self.backTrack(cur, path, res, tickets, used)
    return res[0]

def backTrack(self, cur, path, res, tickets, used):
    if len(path) == len(tickets)+1:
        res.append(path[:])
        return True
    for i in range (len(tickets)):
        if tickets[i][0] == cur and used[i] == 0:
            used[i] = 1
            path.append(tickets[i][1])
            state = self.backTrack(tickets[i][1], path, res, tickets, used)
            used[i] = 0
            path.pop()
            if state == True:
                return True
            
```
