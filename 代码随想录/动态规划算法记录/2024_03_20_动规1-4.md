## Leetcode 746 Min Cost Climbing Stairs

进入动态规划（dynamic programming）的篇章的时候，我们实际上最需要考虑如何去思考和解决一个dynamic programming问题。思路是怎样的。<br>
这里总结一下<br>
<ol>
<li>确定dp的含义以及下标对应的含义</li>
<li>确定dp的递推公式/状态转换公式</li>
<li>从而确认dp的初始化</li>
<li>确认如何遍历目标数组去获得dp</li>
<li>对比代码打出的dp和自己理解的dp是否一致来检查代码是否正确</li>
</ol>
这里的话对于需要最少的cost到达n。<br>
<li>首先确认dp的含义，我们定义dp[n]为，到达当前台阶n，需要的最少的cost。</li>
<li>那么递推公式就会很简单明了了。dp[n]可以由两种状态转化过来。1是dp[n-1],2是dp[n-2]。这两种状态消耗的cost 分别是dp[n-1] + cost[n-1], dp[n-2] + cost[n-2]。我们当然是取最小值，所以用一个min函数。</li>
<li>然后确认dp的初始化，因为我们有n-2。所以至少初始化两个值。由于我们可以从台阶0或者1直接开始，那么到达台阶0和1的cost都应该是0。而不是有cost。因为题目很清楚了，我们从当前台阶往上走才需要消耗cost，我们一出生就在0或者1，是不需要消耗0或者1上的cost的。</li>
<li>通过递推公式我们也可以很清楚的知道，遍历顺序是从前往后的。</li>
有了这些思路可以得到如下代码
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int])->int:
        # 这里一开始理解的是num = len(cost)，但是发现题目要求是需要+1，这就需要打出dp来发现区别了
        num = len(cost)+1
        dp = [0] * num
        dp[0], dp[1] = 0, 0
        for i in range (2, num):
            dp[i] = min((dp[i-1]+cost[i-1]), (dp[i-2]+cost[i-2]))
        return dp[num-1]

```

实际上这个题目可以从空间上进行优化，即我们的dp数组因为是和前两个元素有关，我们可以释放掉之前计算过的值，只用两个variable去更新即可。
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int])->int:
        num = len(cost) + 1
        dp0 = 0
        dp1 = 0

        for i in range (2, num):
            dp2 = min((dp1+cost[i-1]), (dp0+cost[i-2]))
            dp0 = dp1
            dp1 = dp2

        return dp1

```