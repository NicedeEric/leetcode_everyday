## Leetcode 122 Best Time to Buy and Sell Stock II

本题要求是return最大的profit。第一反应可以是寻找波峰波谷去进行计算，但是这样不够简洁<br>
实际上考虑一个数组prices。第二天的利润实际上是prices[1] - prices[0],第三天的利润是prices[2] - prices[1]。假如从第一天买入，第三天卖出，那么利润是prices[2] - prices[0] = (prices[2] - prices[1]) + (prices[1] - prices[0])。所以通过这个思路，我们意识到，利润是可以拆分成每天的利润的简单求和的。<br>
那么本题就会变得非常简单，我们只需要计算出所有的利润，然后简单求和正的利润就可以得到最后的结果了。

## Leetcode 55 Jump Game

本题的要求是询问是否可以到达终点，我们考虑的实际上不需要是在当前的格子选择跳到哪，而是当前所有格子的最远的coverage。然后我们从1一直遍历到当前最远的coverage，假如最后coverage 会 大于等于最后的len(nums)-1,那么说明是可以的，不然就return False

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1:
            return True
        i=0
        while i <= cover:
            cover = max(cover, nums[i] + i)
            if cover >= len(nums)-1:
                return True
            i += 1
        return False
```