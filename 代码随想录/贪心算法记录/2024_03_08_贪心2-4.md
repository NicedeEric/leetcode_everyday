## Leetcode 376 Wiggle Subsequence

## Leetcode 53 Maximum Subarray
本题的贪心算法思路：<br>
当一个子序列，添加完第i个值之后，已经是负数的情况下，应该从i+1重新开始计算count的值，因为之前的所有序列提供的值都会是负数，对于获得最大和的子序列没有帮助<br>
计算最大的和的情况是每次获得count的时候，就进行一个比较，去maintian maxcount这样一个全局变量

```python
class Solution:
    def maxSubArray(self, nums: List[int]):
        count = 0
        maxCount = nums[0]
        for i in range (len(nums)):
            if count >= 0:
                count += nums[i]
                maxCount = max(count, maxCount)
            else:
                count = nums[i]
                maxCount = max(count, maxCount)
        return maxCount
```